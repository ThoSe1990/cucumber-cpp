// TODO!

// https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGIM6SuADJ4DJgAcj4ARpjEEhoapAAOqAqETgwe3r7%2ByanpAiFhkSwxcVwJtpj2jgJCBEzEBFk%2BflxVNRn1jQRFEdGxegoNTS057cM9fSVlEgCUtqhexMjsHOYAzKHI3lgA1CYbbk7DxJish9gmGgCCm9u7mAdHYsAkhAgsl9d3ZlsMOy8%2B0ObjYLBIAE9vrd7gDHs83AQIUlMKEsKpob9/oDgUckSjQvxMbCcU8QV4GCQsGd0AB9FhMJLE27MNgKJJMVZ7ZAAdwIBwA7FYYbcdkwFApuQhGpyCLEDjChT8kl4orQ8MgQD89jqpTKHLEIHNngARPZYKhMLy0AiHCwKm66vZylhJAxykH4xisJ4AFUuDqdyGlxFlhv9ZgAbOZI3sAG5iLyYY0mJW3J1Oli0hPeMkbM3DdAgEAMgDWmFpFLwAEckyDkPSMNUQf6Nlc2xBC8XwXHMBAc0m5nM7drdamTT9RzqXW6mB68cjvWw9q3sIHdRHY8BMAQjYLhY6MzqzgRlgw9pNHA3RMN642sLQW5cAFSXCBZgeYAB0293Q4AtJcH6JpgI7pmOAoTiKNxJMQeAJnKIBjuBOqnF4DjcrSaAApgST8qmB5HjqcZ4E0XhiHsAB%2B14CKseF7gR45ToKE4bAezEzu6oELiirJ%2BpiTpoRhDbgg%2BexISqaoaph2F0fhKH7sxQb3tUEC%2BtyAi3lG8YgSmClOkhwG5v2umKZBYF3PpG57EZdZscxTH2dBsHwXO7DMV2IBVrWFZ4cQd6ybhtptjZ2YgRZjnsYqZoAPQxXsfHspyTy8vJlk3EJ/L8KgingXGqB4OgewIHgDFCheBBFigSz4UcII6bmCL1Z5riPmxLGjqE/KfqaexcH8EXmU5GUEMQ6H8lEjS5Ye%2BWFXsVBlfanloF4tVuPV5hmIQkqTcQBxmGYTVHBVVWtXaHXRRF0E/JxbkIl6fErpi2HDJgqiwSdxZerSaJvXsv6%2BouACSJqLcxJ5np9IDfb9qgQF6hVqUOg1QelmUaYIb34Wm6XTpgrpcZ6i6Pauo6bv9O4MeBjEKXgVB7BA6BzkwX4rYI0A7oDKIg0%2BHZDqahxmhoKY40eTMNCYACsFgA8DrFuKuRpS2agtPUqQ2ERBqNOhDxDnuLTBSzLnNy7z2BK5LJpfrdcoU8FCtvsOw06kx0GoZVxYUlSsSYHSDJMkcnkwww6KkNyfLFsG%2Bpyv5IUGyjV03F1NlMKESui%2Bu2Fyqo/KmO1o7ID%2BO4gtljtfiVSvO9yRf26XfNfj1qsAJwtxZOqF7%2BJeoKgZcV07msd8XRy7WXC395O4GFwbrP0I0lcDzXXc9/XfeJ3FUNe8Q1K%2B/SjIgkHi4/SHb1h6lkchmGsdrvHw3r/H0uy9z8t1%2Bbw6W71Z8oBfBrENQ3eMZBce0E77MyNo/TAPMjgvwtlbTuUD/4r1KkA9K68gwRy/tHeUUdQw/wIqXdWE4NY/FQbqT%2B2DL56hwTHMwBER4EMisQ%2BKQZv7UMXsPRoo954OVuCQ9uLDYhsLcNAuY5ckEWV4ZQy%2BgjhENxAr1SQktoy3yYaQ/hxBpEINfqIrhCkJ6Hh1OvUu2l6aq3IT/DRy9X5t2QncSCHAFi0E4JLXgfgOBaFIKgTg61LDWAvEsFYZI/g8FIAQTQ9iFilhAJISQX4AAcsTJYHQ0JIDQkZYlcCblIfQnBJAuLCR4zgvAFAgESKEtx9jSBwFgDARA1VXR0FiOQSgaB6n0DiMALg/VSBYBIqsAAangTAPIADyvFODBJoDaWIxSIBRHyVEUIjQITjN4As5gxAITDKiNoTADgVmkBaWwQQwyGC0GWeU7pmAoheGAG4MQtBincF4FgBkRhxAXPwGcBw8FMCPPcW9XZq01juK6tUfJ6ooihg2R4LA%2BzRp4BYCshYVADDAAUAMoZozGD7P4IIEQYh2BZNxfIJQah8m6HaAYIwKBrDWH0HgKIxTIALFQHhDIjz/yFkFqYHxlgzAaD2P%2BYZGxeCoF7MQOCWAmVGg6Ls2ofgICuDGG0QIIdpgDHKHkNI8rlV6BSNqjI6rSiDAmNUOVXQRjNE8K0IYZrvl1EtUa2YExLW6pdVMUI/RjXlAWAofxqx5jZI4M40grj3GeI4HsVQsTIz/kjJIf6yBkB9S4F%2BQ6EBcCEBIPtDYXA5i8DKVoIcpBImSFTVwAUaSNgaErVwSMTdJCxI2EG3JpBEWS0SGG0VhTbAlJCWEhYVTak1RVAQJpir8BEElXoYl%2BLxBEtkIoFQ6gLkUtIDyUMSQkVBpDV2gpHBhmrVHXsVA9No2xvjYm5NnS00Mw8K0%2BUmw80FoHQ4nJvB22dvyRGopfbC3hJLSASWksvydMkAKAUTdJZN1zbEjQsSm5BpFaG79Pb/3FscRwMweSLk/v7eU4t4q0jOEkEAA


#include <iostream>
#include <algorithm>
#include <memory>
#include <typeindex>
#include <typeinfo>
#include <unordered_map>

extern "C" {
  #include "cwt/cucumber_value.h"
}

namespace cuke {
  namespace details {

    class context_type
    {
    public:
        context_type() = default; 

        template<typename T> 
        context_type(T&& value) 
        {
          m_value = std::make_unique<c_model<T>>(std::move(value));
        }

        template<typename T> 
        T& get() 
        {
          return static_cast<c_model<T>*>(m_value.get())->m_value;
        }

    private:   
        struct c_concept 
        {
            virtual ~c_concept() {}
        };

        template<typename T>
        struct c_model : public c_concept 
        {
            c_model(T const& value) 
              : m_value(value) {};
            T m_value;
        };

    private:
        std::unique_ptr<c_concept> m_value;
    };

} // namespace details 

  template <typename T>
  constexpr std::type_index get_type_id() 
  {
      return std::type_index(typeid(T));
  }

  class scenario_context
  {
    public:
    //TODO another get method: forward values to ctor
      template<typename T>
      T& get() 
      {
        if (m_data.count(get_type_id<T>()) == 0) {
          m_data[get_type_id<T>()] = T{};
        }
        return m_data[get_type_id<T>()].template get<T>();
      }

      void clear() 
      {
        m_data.clear();
      }
    private:
      std::unordered_map<std::type_index, details::context_type> m_data;
  };

  namespace details
  {
    scenario_context& get_context()
    {
      static scenario_context sc; 
      return sc;
    }
  
    void reset_scenario_context(int, cuke_value*)
    {
      std::cout << "clearing context!" << std::endl;
      get_context().clear();
    }
  } // namespace details
  
  template<typename T>
  T& context()
  {
    return details::get_context().get<T>();
  }

  template<typename T>
  void assert_equal(T t1, T t2)
  {
    cuke_assert(t1 == t2);
  }

} // namespace cuke 
